<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Holomorphic Spectrum Viewer</title>
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        margin: 0;
        font-family: "Helvetica Neue", Arial, sans-serif;
        background: #0c0c0f;
        color: #f3f3f3;
      }
      header {
        padding: 24px 32px 12px;
      }
      h1 {
        margin: 0 0 8px 0;
        font-size: 1.6rem;
      }
      p {
        margin: 0 0 16px 0;
        max-width: 70ch;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      .control {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 0.9rem;
      }
      .control input[type="range"] {
        width: 220px;
      }
      .range-value {
        font-variant-numeric: tabular-nums;
        opacity: 0.8;
      }
      .control-group {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      .hidden {
        display: none !important;
      }
      .panel {
        padding: 12px 32px 24px;
      }
      canvas {
        width: 100%;
        max-width: 960px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: #101018;
        display: block;
      }
      .status {
        font-size: 0.9rem;
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Holomorphic Spectrum Viewer</h1>
      <p>
        Switch between a temporal-field view derived from an uploaded image and a WebGL-rendered
        5D holomorphic spectrum. The spectrum view evaluates a 5D Fourier transform of a
        holomorphic Gaussian envelope, mapping its phase (hue) and amplitude (brightness).
      </p>
      <div class="controls">
        <label class="control">
          <span>Mode</span>
          <select id="mode-select">
            <option value="spectrum" selected>5D Fourier spectrum</option>
            <option value="temporal">Temporal field (image upload)</option>
          </select>
        </label>
        <div class="control-group" id="image-controls">
          <label class="control">
            <span>Image upload</span>
            <input id="image-upload" type="file" accept="image/*" />
          </label>
        </div>
        <div class="control-group" id="spectrum-controls">
          <label class="control">
            <span>σ (envelope)</span>
            <input id="sigma-input" type="range" min="0.25" max="1.2" step="0.05" value="0.6" />
            <span class="range-value" id="sigma-value">0.60</span>
          </label>
          <label class="control">
            <span>Coupling</span>
            <input id="coupling-input" type="range" min="0.0" max="2.0" step="0.05" value="1.0" />
            <span class="range-value" id="coupling-value">1.00</span>
          </label>
          <label class="control">
            <span>Twist</span>
            <input id="twist-input" type="range" min="0.0" max="1.0" step="0.05" value="0.35" />
            <span class="range-value" id="twist-value">0.35</span>
          </label>
          <label class="control">
            <span>k₃ slice</span>
            <input id="k3-input" type="range" min="-1.5" max="1.5" step="0.05" value="0.4" />
            <span class="range-value" id="k3-value">0.40</span>
          </label>
          <label class="control">
            <span>k₄ slice</span>
            <input id="k4-input" type="range" min="-1.5" max="1.5" step="0.05" value="-0.35" />
            <span class="range-value" id="k4-value">-0.35</span>
          </label>
          <label class="control">
            <span>k₅ slice</span>
            <input id="k5-input" type="range" min="-1.5" max="1.5" step="0.05" value="0.2" />
            <span class="range-value" id="k5-value">0.20</span>
          </label>
        </div>
        <span class="status" id="status">Rendering 5D Fourier spectrum.</span>
      </div>
    </header>
    <div class="panel">
      <canvas id="temporal-field-canvas" width="640" height="480"></canvas>
    </div>
    <script>
      const modeSelect = document.getElementById("mode-select");
      const upload = document.getElementById("image-upload");
      const imageControls = document.getElementById("image-controls");
      const spectrumControls = document.getElementById("spectrum-controls");
      const status = document.getElementById("status");
      const canvas = document.getElementById("temporal-field-canvas");
      const gl = canvas.getContext("webgl");
      const sigmaInput = document.getElementById("sigma-input");
      const couplingInput = document.getElementById("coupling-input");
      const twistInput = document.getElementById("twist-input");
      const k3Input = document.getElementById("k3-input");
      const k4Input = document.getElementById("k4-input");
      const k5Input = document.getElementById("k5-input");
      const sigmaValue = document.getElementById("sigma-value");
      const couplingValue = document.getElementById("coupling-value");
      const twistValue = document.getElementById("twist-value");
      const k3Value = document.getElementById("k3-value");
      const k4Value = document.getElementById("k4-value");
      const k5Value = document.getElementById("k5-value");

      if (!gl) {
        status.textContent = "WebGL unavailable in this browser.";
      }

      const vertexSource = `
        attribute vec2 position;
        attribute vec2 texCoord;
        varying vec2 vTexCoord;
        void main() {
          vTexCoord = texCoord;
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `;

      const fragmentSource = `
        precision mediump float;
        varying vec2 vTexCoord;
        uniform sampler2D uTexture;
        void main() {
          gl_FragColor = texture2D(uTexture, vTexCoord);
        }
      `;

      function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error(info);
        }
        return shader;
      }

      function createProgram() {
        const program = gl.createProgram();
        const vertexShader = compileShader(gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentSource);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error(info);
        }
        return program;
      }

      const program = gl ? createProgram() : null;
      if (gl) {
        gl.useProgram(program);
      }

      const quadVertices = new Float32Array([
        -1, -1, 0, 0,
         1, -1, 1, 0,
        -1,  1, 0, 1,
         1,  1, 1, 1,
      ]);

      const buffer = gl ? gl.createBuffer() : null;
      if (gl) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);
        const positionLoc = gl.getAttribLocation(program, "position");
        const texCoordLoc = gl.getAttribLocation(program, "texCoord");
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 16, 0);
        gl.enableVertexAttribArray(texCoordLoc);
        gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 16, 8);
      }

      const texture = gl ? gl.createTexture() : null;
      if (gl) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      }

      function hsvToRgb(h, s, v) {
        const i = Math.floor(h * 6);
        const f = h * 6 - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);
        const mod = i % 6;
        let r = v;
        let g = t;
        let b = p;
        if (mod === 1) {
          r = q; g = v; b = p;
        } else if (mod === 2) {
          r = p; g = v; b = t;
        } else if (mod === 3) {
          r = p; g = q; b = v;
        } else if (mod === 4) {
          r = t; g = p; b = v;
        } else if (mod === 5) {
          r = v; g = p; b = q;
        }
        return [r, g, b];
      }

      function computeTemporalFields(imageData) {
        const width = imageData.width;
        const height = imageData.height;
        const data = imageData.data;
        const total = width * height;
        const luminance = new Float32Array(total);
        const phase = new Float32Array(total);
        const temporal = new Float32Array(total);

        for (let i = 0; i < total; i++) {
          const idx = i * 4;
          const r = data[idx] / 255;
          const g = data[idx + 1] / 255;
          const b = data[idx + 2] / 255;
          luminance[i] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        }

        function index(x, y) {
          const wrappedX = (x + width) % width;
          const wrappedY = (y + height) % height;
          return wrappedY * width + wrappedX;
        }

        let minTemporal = Number.POSITIVE_INFINITY;
        let maxTemporal = Number.NEGATIVE_INFINITY;
        const twoPi = Math.PI * 2;

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const centerIndex = index(x, y);
            const left = luminance[index(x - 1, y)];
            const right = luminance[index(x + 1, y)];
            const up = luminance[index(x, y - 1)];
            const down = luminance[index(x, y + 1)];
            const gradX = 0.5 * (right - left);
            const gradY = 0.5 * (down - up);
            const phaseAngle = (Math.atan2(gradY, gradX) + twoPi) % twoPi;
            phase[centerIndex] = phaseAngle;
            const laplacian = left + right + up + down - 4 * luminance[centerIndex];
            const magnitude = Math.abs(laplacian);
            temporal[centerIndex] = magnitude;
            minTemporal = Math.min(minTemporal, magnitude);
            maxTemporal = Math.max(maxTemporal, magnitude);
          }
        }

        const range = Math.max(maxTemporal - minTemporal, 1e-8);
        for (let i = 0; i < total; i++) {
          temporal[i] = (temporal[i] - minTemporal) / range;
        }

        return {
          width,
          height,
          phase,
          magnitude: temporal,
          minMagnitude: minTemporal,
          maxMagnitude: maxTemporal,
          label: "Temporal-field range",
        };
      }

      function computeSpectrumFields(width, height, params) {
        const total = width * height;
        const phase = new Float32Array(total);
        const magnitude = new Float32Array(total);
        const twoPi = Math.PI * 2;
        const extent = 2.25;
        let minMagnitude = Number.POSITIVE_INFINITY;
        let maxMagnitude = Number.NEGATIVE_INFINITY;

        for (let y = 0; y < height; y++) {
          const v = (y / (height - 1)) * 2 - 1;
          for (let x = 0; x < width; x++) {
            const u = (x / (width - 1)) * 2 - 1;
            const k0 = u * extent;
            const k1 = v * extent;
            const k2 = params.k3;
            const k3 = params.k4;
            const k4 = params.k5;
            const shifted0 = k0;
            const shifted1 = k1;
            const shifted2 = k2;
            const shifted3 = k3;
            const shifted4 = k4;
            const normSq =
              shifted0 * shifted0 +
              shifted1 * shifted1 +
              shifted2 * shifted2 +
              shifted3 * shifted3 +
              shifted4 * shifted4;
            const envelope = Math.exp(
              -2 * Math.PI * Math.PI * params.sigma * params.sigma * normSq
            );
            const phaseAngle =
              twoPi *
              (params.coupling * (shifted0 * shifted1 - shifted2 * shifted3) +
                params.twist * shifted4);
            const idx = y * width + x;
            phase[idx] = ((phaseAngle % twoPi) + twoPi) % twoPi;
            magnitude[idx] = envelope;
            minMagnitude = Math.min(minMagnitude, envelope);
            maxMagnitude = Math.max(maxMagnitude, envelope);
          }
        }

        const range = Math.max(maxMagnitude - minMagnitude, 1e-8);
        for (let i = 0; i < total; i++) {
          magnitude[i] = (magnitude[i] - minMagnitude) / range;
        }

        return {
          width,
          height,
          phase,
          magnitude,
          minMagnitude,
          maxMagnitude,
          label: "Spectrum amplitude range",
        };
      }

      function renderFields(fields) {
        const { width, height, phase, magnitude, minMagnitude, maxMagnitude, label } = fields;
        canvas.width = width;
        canvas.height = height;
        if (!gl) {
          return;
        }
        gl.viewport(0, 0, width, height);
        const pixels = new Uint8Array(width * height * 4);
        const twoPi = Math.PI * 2;
        for (let i = 0; i < width * height; i++) {
          const hue = phase[i] / twoPi;
          const value = magnitude[i];
          const [r, g, b] = hsvToRgb(hue, 1, value);
          const base = i * 4;
          pixels[base] = Math.round(r * 255);
          pixels[base + 1] = Math.round(g * 255);
          pixels[base + 2] = Math.round(b * 255);
          pixels[base + 3] = 255;
        }
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          width,
          height,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          pixels
        );
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        status.textContent = `Rendered ${width}×${height} | ${label} [${minMagnitude.toFixed(
          4
        )}, ${maxMagnitude.toFixed(4)}]`;
      }

      function syncSlider(input, output) {
        output.textContent = Number.parseFloat(input.value).toFixed(2);
      }

      function spectrumParams() {
        return {
          sigma: Number.parseFloat(sigmaInput.value),
          coupling: Number.parseFloat(couplingInput.value),
          twist: Number.parseFloat(twistInput.value),
          k3: Number.parseFloat(k3Input.value),
          k4: Number.parseFloat(k4Input.value),
          k5: Number.parseFloat(k5Input.value),
        };
      }

      function renderSpectrum() {
        if (!gl) {
          return;
        }
        const size = 512;
        const fields = computeSpectrumFields(size, size, spectrumParams());
        renderFields(fields);
      }

      upload.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (!file) {
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => {
            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const ctx = tempCanvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            const fields = computeTemporalFields(imageData);
            renderFields(fields);
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
        status.textContent = "Processing image...";
      });

      function setMode(mode) {
        if (!gl) {
          status.textContent = "WebGL unavailable in this browser.";
          return;
        }
        const isSpectrum = mode === "spectrum";
        imageControls.classList.toggle("hidden", isSpectrum);
        spectrumControls.classList.toggle("hidden", !isSpectrum);
        if (isSpectrum) {
          status.textContent = "Rendering 5D Fourier spectrum.";
          renderSpectrum();
        } else {
          status.textContent = "Awaiting image upload.";
        }
      }

      [
        [sigmaInput, sigmaValue],
        [couplingInput, couplingValue],
        [twistInput, twistValue],
        [k3Input, k3Value],
        [k4Input, k4Value],
        [k5Input, k5Value],
      ].forEach(([input, output]) => {
        syncSlider(input, output);
        input.addEventListener("input", () => {
          syncSlider(input, output);
          if (modeSelect.value === "spectrum") {
            renderSpectrum();
          }
        });
      });

      modeSelect.addEventListener("change", () => {
        setMode(modeSelect.value);
      });

      setMode(modeSelect.value);
    </script>
  </body>
</html>
