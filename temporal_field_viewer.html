<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Holomorphic Spectrum Viewer</title>
    <style>
      :root {
        color-scheme: light dark;
      }
      body {
        margin: 0;
        font-family: "Helvetica Neue", Arial, sans-serif;
        background: #0c0c0f;
        color: #f3f3f3;
      }
      header {
        padding: 24px 32px 12px;
      }
      h1 {
        margin: 0 0 8px 0;
        font-size: 1.6rem;
      }
      p {
        margin: 0 0 16px 0;
        max-width: 70ch;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      .control {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 0.9rem;
      }
      .control input[type="range"] {
        width: 220px;
      }
      .range-value {
        font-variant-numeric: tabular-nums;
        opacity: 0.8;
      }
      .control-group {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      .hidden {
        display: none !important;
      }
      .panel {
        padding: 12px 32px 24px;
      }
      canvas {
        width: 100%;
        max-width: 960px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: #101018;
        display: block;
      }
      .status {
        font-size: 0.9rem;
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Holomorphic Spectrum Viewer</h1>
      <p>
        Switch between a temporal-field view derived from an uploaded image and a WebGL-rendered
        5D holomorphic spectrum. The spectrum view evaluates a 5D Fourier transform of the
        uploaded image (phase as hue, amplitude as brightness).
      </p>
      <div class="controls">
        <label class="control">
          <span>Mode</span>
          <select id="mode-select">
            <option value="spectrum" selected>5D Fourier spectrum</option>
            <option value="temporal">Temporal field (image upload)</option>
          </select>
        </label>
        <div class="control-group" id="image-controls">
          <label class="control">
            <span>Image upload</span>
            <input id="image-upload" type="file" accept="image/*" />
          </label>
        </div>
        <div class="control-group" id="spectrum-controls">
          <label class="control">
            <span>k-range</span>
            <input id="k-range-input" type="range" min="0.25" max="2.5" step="0.05" value="1.2" />
            <span class="range-value" id="k-range-value">1.20</span>
          </label>
          <label class="control">
            <span>k₃ slice</span>
            <input id="k3-input" type="range" min="-1.5" max="1.5" step="0.05" value="0.4" />
            <span class="range-value" id="k3-value">0.40</span>
          </label>
          <label class="control">
            <span>k₄ slice</span>
            <input id="k4-input" type="range" min="-1.5" max="1.5" step="0.05" value="-0.35" />
            <span class="range-value" id="k4-value">-0.35</span>
          </label>
          <label class="control">
            <span>k₅ slice</span>
            <input id="k5-input" type="range" min="-1.5" max="1.5" step="0.05" value="0.2" />
            <span class="range-value" id="k5-value">0.20</span>
          </label>
        </div>
        <span class="status" id="status">Upload an image to render the 5D Fourier spectrum.</span>
      </div>
    </header>
    <div class="panel">
      <canvas id="temporal-field-canvas" width="640" height="480"></canvas>
    </div>
    <script>
      const modeSelect = document.getElementById("mode-select");
      const upload = document.getElementById("image-upload");
      const imageControls = document.getElementById("image-controls");
      const spectrumControls = document.getElementById("spectrum-controls");
      const status = document.getElementById("status");
      const canvas = document.getElementById("temporal-field-canvas");
      const gl = canvas.getContext("webgl");
      const kRangeInput = document.getElementById("k-range-input");
      const k3Input = document.getElementById("k3-input");
      const k4Input = document.getElementById("k4-input");
      const k5Input = document.getElementById("k5-input");
      const kRangeValue = document.getElementById("k-range-value");
      const k3Value = document.getElementById("k3-value");
      const k4Value = document.getElementById("k4-value");
      const k5Value = document.getElementById("k5-value");
      let embedding = null;
      let lastImageData = null;

      if (!gl) {
        status.textContent = "WebGL unavailable in this browser.";
      }

      const vertexSource = `
        attribute vec2 position;
        attribute vec2 texCoord;
        varying vec2 vTexCoord;
        void main() {
          vTexCoord = texCoord;
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `;

      const fragmentSource = `
        precision mediump float;
        varying vec2 vTexCoord;
        uniform sampler2D uTexture;
        void main() {
          gl_FragColor = texture2D(uTexture, vTexCoord);
        }
      `;

      function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error(info);
        }
        return shader;
      }

      function createProgram() {
        const program = gl.createProgram();
        const vertexShader = compileShader(gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentSource);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error(info);
        }
        return program;
      }

      const program = gl ? createProgram() : null;
      if (gl) {
        gl.useProgram(program);
      }

      const quadVertices = new Float32Array([
        -1, -1, 0, 0,
         1, -1, 1, 0,
        -1,  1, 0, 1,
         1,  1, 1, 1,
      ]);

      const buffer = gl ? gl.createBuffer() : null;
      if (gl) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);
        const positionLoc = gl.getAttribLocation(program, "position");
        const texCoordLoc = gl.getAttribLocation(program, "texCoord");
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 16, 0);
        gl.enableVertexAttribArray(texCoordLoc);
        gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 16, 8);
      }

      const texture = gl ? gl.createTexture() : null;
      if (gl) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      }

      function hsvToRgb(h, s, v) {
        const i = Math.floor(h * 6);
        const f = h * 6 - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);
        const mod = i % 6;
        let r = v;
        let g = t;
        let b = p;
        if (mod === 1) {
          r = q; g = v; b = p;
        } else if (mod === 2) {
          r = p; g = v; b = t;
        } else if (mod === 3) {
          r = p; g = q; b = v;
        } else if (mod === 4) {
          r = t; g = p; b = v;
        } else if (mod === 5) {
          r = v; g = p; b = q;
        }
        return [r, g, b];
      }

      function computeTemporalFields(imageData) {
        const width = imageData.width;
        const height = imageData.height;
        const data = imageData.data;
        const total = width * height;
        const luminance = new Float32Array(total);
        const phase = new Float32Array(total);
        const temporal = new Float32Array(total);

        for (let i = 0; i < total; i++) {
          const idx = i * 4;
          const r = data[idx] / 255;
          const g = data[idx + 1] / 255;
          const b = data[idx + 2] / 255;
          luminance[i] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        }

        function index(x, y) {
          const wrappedX = (x + width) % width;
          const wrappedY = (y + height) % height;
          return wrappedY * width + wrappedX;
        }

        let minTemporal = Number.POSITIVE_INFINITY;
        let maxTemporal = Number.NEGATIVE_INFINITY;
        const twoPi = Math.PI * 2;

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const centerIndex = index(x, y);
            const left = luminance[index(x - 1, y)];
            const right = luminance[index(x + 1, y)];
            const up = luminance[index(x, y - 1)];
            const down = luminance[index(x, y + 1)];
            const gradX = 0.5 * (right - left);
            const gradY = 0.5 * (down - up);
            const phaseAngle = (Math.atan2(gradY, gradX) + twoPi) % twoPi;
            phase[centerIndex] = phaseAngle;
            const laplacian = left + right + up + down - 4 * luminance[centerIndex];
            const magnitude = Math.abs(laplacian);
            temporal[centerIndex] = magnitude;
            minTemporal = Math.min(minTemporal, magnitude);
            maxTemporal = Math.max(maxTemporal, magnitude);
          }
        }

        const range = Math.max(maxTemporal - minTemporal, 1e-8);
        for (let i = 0; i < total; i++) {
          temporal[i] = (temporal[i] - minTemporal) / range;
        }

        return {
          width,
          height,
          phase,
          magnitude: temporal,
          minMagnitude: minTemporal,
          maxMagnitude: maxTemporal,
          label: "Temporal-field range",
        };
      }

      function neighborSum(field, width, height) {
        const total = width * height;
        const output = new Float32Array(total);
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let sum = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                const wrappedX = (x + dx + width) % width;
                const wrappedY = (y + dy + height) % height;
                sum += field[wrappedY * width + wrappedX];
              }
            }
            output[y * width + x] = sum;
          }
        }
        return output;
      }

      function normalizeField(field) {
        let minVal = Number.POSITIVE_INFINITY;
        let maxVal = Number.NEGATIVE_INFINITY;
        for (let i = 0; i < field.length; i++) {
          minVal = Math.min(minVal, field[i]);
          maxVal = Math.max(maxVal, field[i]);
        }
        const range = Math.max(maxVal - minVal, 1e-8);
        const output = new Float32Array(field.length);
        for (let i = 0; i < field.length; i++) {
          output[i] = (field[i] - minVal) / range;
        }
        return output;
      }

      function computeEmbedding(imageData) {
        const width = imageData.width;
        const height = imageData.height;
        const data = imageData.data;
        const total = width * height;
        const luminance = new Float32Array(total);
        const r = new Float32Array(total);
        const b = new Float32Array(total);
        for (let i = 0; i < total; i++) {
          const idx = i * 4;
          const red = data[idx] / 255;
          const green = data[idx + 1] / 255;
          const blue = data[idx + 2] / 255;
          r[i] = red;
          b[i] = blue;
          luminance[i] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;
        }

        const luminanceSq = new Float32Array(total);
        for (let i = 0; i < total; i++) {
          luminanceSq[i] = luminance[i] * luminance[i];
        }

        const mean = neighborSum(luminance, width, height);
        const meanSq = neighborSum(luminanceSq, width, height);
        const variance = new Float32Array(total);
        for (let i = 0; i < total; i++) {
          const localMean = mean[i] / 9;
          const localMeanSq = meanSq[i] / 9;
          variance[i] = Math.max(localMeanSq - localMean * localMean, 0);
        }
        const depthField = normalizeField(variance);

        const spectralShift = new Float32Array(total);
        for (let i = 0; i < total; i++) {
          spectralShift[i] = (r[i] - b[i]) / (r[i] + b[i] + 1e-8);
        }

        const phaseField = new Float32Array(total);
        const temporalField = new Float32Array(total);
        const twoPi = Math.PI * 2;
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const center = y * width + x;
            const left = luminance[y * width + (x - 1 + width) % width];
            const right = luminance[y * width + (x + 1) % width];
            const up = luminance[((y - 1 + height) % height) * width + x];
            const down = luminance[((y + 1) % height) * width + x];
            const gradX = 0.5 * (right - left);
            const gradY = 0.5 * (down - up);
            const phaseAngle = (Math.atan2(gradY, gradX) + twoPi) % twoPi;
            phaseField[center] = phaseAngle;
            const laplacian = left + right + up + down - 4 * luminance[center];
            temporalField[center] = Math.abs(laplacian);
          }
        }
        const temporalNormalized = normalizeField(temporalField);

        const points = new Float32Array(total * 5);
        const radiusY = 1.0;
        const depthScale = 1.0;
        const phaseScale = 1.0;
        const temporalScale = 1.0;
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const base = idx * 5;
            points[base] = y;
            points[base + 1] = x;
            points[base + 2] = depthScale * depthField[idx];
            points[base + 3] = phaseScale * phaseField[idx] * radiusY;
            points[base + 4] = temporalScale * temporalNormalized[idx];
          }
        }

        return {
          width,
          height,
          luminance,
          depthField,
          spectralShift,
          phaseField,
          temporalField: temporalNormalized,
          points,
        };
      }

      function computeSpectrumFieldsFromEmbedding(params) {
        const size = 128;
        const phase = new Float32Array(size * size);
        const magnitude = new Float32Array(size * size);
        const twoPi = Math.PI * 2;
        let minMagnitude = Number.POSITIVE_INFINITY;
        let maxMagnitude = Number.NEGATIVE_INFINITY;
        const total = embedding.luminance.length;
        const constPhase = new Float32Array(total);

        for (let i = 0; i < total; i++) {
          const base = i * 5;
          const x3 = embedding.points[base + 2];
          const y = embedding.points[base + 3];
          const t = embedding.points[base + 4];
          constPhase[i] = params.k3 * x3 + params.k4 * y + params.k5 * t;
        }

        for (let y = 0; y < size; y++) {
          const v = (y / (size - 1)) * 2 - 1;
          const k1 = v * params.kRange;
          for (let x = 0; x < size; x++) {
            const u = (x / (size - 1)) * 2 - 1;
            const k0 = u * params.kRange;
            let sumReal = 0;
            let sumImag = 0;
            for (let i = 0; i < total; i++) {
              const base = i * 5;
              const x1 = embedding.points[base];
              const x2 = embedding.points[base + 1];
              const phaseAngle = -twoPi * (k0 * x1 + k1 * x2 + constPhase[i]);
              const amp = embedding.luminance[i];
              sumReal += amp * Math.cos(phaseAngle);
              sumImag += amp * Math.sin(phaseAngle);
            }
            const idx = y * size + x;
            const mag = Math.hypot(sumReal, sumImag);
            phase[idx] = (Math.atan2(sumImag, sumReal) + twoPi) % twoPi;
            magnitude[idx] = mag;
            minMagnitude = Math.min(minMagnitude, mag);
            maxMagnitude = Math.max(maxMagnitude, mag);
          }
        }

        const range = Math.max(maxMagnitude - minMagnitude, 1e-8);
        for (let i = 0; i < magnitude.length; i++) {
          magnitude[i] = (magnitude[i] - minMagnitude) / range;
        }

        return {
          width: size,
          height: size,
          phase,
          magnitude,
          minMagnitude,
          maxMagnitude,
          label: "Spectrum amplitude range",
        };
      }

      function renderFields(fields) {
        const { width, height, phase, magnitude, minMagnitude, maxMagnitude, label } = fields;
        canvas.width = width;
        canvas.height = height;
        if (!gl) {
          return;
        }
        gl.viewport(0, 0, width, height);
        const pixels = new Uint8Array(width * height * 4);
        const twoPi = Math.PI * 2;
        for (let i = 0; i < width * height; i++) {
          const hue = phase[i] / twoPi;
          const value = magnitude[i];
          const [r, g, b] = hsvToRgb(hue, 1, value);
          const base = i * 4;
          pixels[base] = Math.round(r * 255);
          pixels[base + 1] = Math.round(g * 255);
          pixels[base + 2] = Math.round(b * 255);
          pixels[base + 3] = 255;
        }
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          width,
          height,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          pixels
        );
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        status.textContent = `Rendered ${width}×${height} | ${label} [${minMagnitude.toFixed(
          4
        )}, ${maxMagnitude.toFixed(4)}]`;
      }

      function syncSlider(input, output) {
        output.textContent = Number.parseFloat(input.value).toFixed(2);
      }

      function spectrumParams() {
        return {
          kRange: Number.parseFloat(kRangeInput.value),
          k3: Number.parseFloat(k3Input.value),
          k4: Number.parseFloat(k4Input.value),
          k5: Number.parseFloat(k5Input.value),
        };
      }

      function renderSpectrum() {
        if (!gl) {
          return;
        }
        if (!embedding) {
          status.textContent = "Upload an image to render the 5D Fourier spectrum.";
          return;
        }
        const fields = computeSpectrumFieldsFromEmbedding(spectrumParams());
        renderFields(fields);
      }

      upload.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (!file) {
          return;
        }
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => {
            const tempCanvas = document.createElement("canvas");
            const maxSize = 64;
            const scale = Math.min(1, maxSize / Math.max(img.width, img.height));
            tempCanvas.width = Math.max(1, Math.round(img.width * scale));
            tempCanvas.height = Math.max(1, Math.round(img.height * scale));
            const ctx = tempCanvas.getContext("2d");
            ctx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
            const downsampled = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            embedding = computeEmbedding(downsampled);
            lastImageData = downsampled;
            if (modeSelect.value === "temporal") {
              const fields = computeTemporalFields(downsampled);
              renderFields(fields);
            } else {
              renderSpectrum();
            }
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
        status.textContent = "Processing image...";
      });

      function setMode(mode) {
        if (!gl) {
          status.textContent = "WebGL unavailable in this browser.";
          return;
        }
        const isSpectrum = mode === "spectrum";
        imageControls.classList.toggle("hidden", isSpectrum);
        spectrumControls.classList.toggle("hidden", !isSpectrum);
        if (isSpectrum) {
          renderSpectrum();
        } else {
          if (!embedding || !lastImageData) {
            status.textContent = "Awaiting image upload.";
          } else {
            const fields = computeTemporalFields(lastImageData);
            renderFields(fields);
          }
        }
      }

      [
        [kRangeInput, kRangeValue],
        [k3Input, k3Value],
        [k4Input, k4Value],
        [k5Input, k5Value],
      ].forEach(([input, output]) => {
        syncSlider(input, output);
        input.addEventListener("input", () => {
          syncSlider(input, output);
          if (modeSelect.value === "spectrum") {
            renderSpectrum();
          }
        });
      });

      modeSelect.addEventListener("change", () => {
        setMode(modeSelect.value);
      });

      setMode(modeSelect.value);
    </script>
  </body>
</html>
